// Code generated by github.com/atombender/go-jsonschema, DO NOT EDIT.

package genjsonschema

import "encoding/json"
import "fmt"

// A detailed representation of a term for the purpuse of learning the language.
type AiDictionaryEntryConfig struct {
	// A list of all the different meanings of the term. Each separate meaning can
	// have a different pronunciation, grammatical form, part of speech, synonyms, and
	// usage examples. The order of the meanings should be from most to least common
	// usage. The logic of separation should be the closest to the most established
	// dictionary logic. Include all the meanings of the term known, including the
	// folkloric ones. The purpose is to generate a single source of truth for the
	// term in the language. Known issues to avoid:  - Insufficient number of meanings
	// despite the explicit request to include all known meanings.
	Meanings []AiDictionaryEntryConfigMeaningsElem `json:"meanings" yaml:"meanings" mapstructure:"meanings"`

	// The original language of the word in a BCP 47 format. The value should be
	// guessed based on the word itself and the `userLearningLanguages` parameter in
	// case of ambiguity. Multiple values are possible, in that case they should be
	// ordered by priority based on the best fit and the `userLearningLanguages`
	// parameter.
	SourceLanguage string `json:"sourceLanguage" yaml:"sourceLanguage" mapstructure:"sourceLanguage"`
}

type AiDictionaryEntryConfigMeaningsElem struct {
	// A detailed definition of the word in the original language.
	DefinitionOriginal string `json:"definitionOriginal" yaml:"definitionOriginal" mapstructure:"definitionOriginal"`

	// A detailed definition of the word in the target language.
	DefinitionTranslated string `json:"definitionTranslated" yaml:"definitionTranslated" mapstructure:"definitionTranslated"`

	// The word in a neutral grammatic form of the original language.
	NeutralForm string `json:"neutralForm" yaml:"neutralForm" mapstructure:"neutralForm"`

	// A comma separated list of the most common pronunciations of the original word
	// given in IPA format.The order should be from most to least common
	// pronounciations.
	Pronounciation string `json:"pronounciation" yaml:"pronounciation" mapstructure:"pronounciation"`

	// Common synonyms in the original language.
	Synonyms string `json:"synonyms" yaml:"synonyms" mapstructure:"synonyms"`

	// A translation of `translatingTerm` parameter to the language defined by a
	// `translationLanguage` parameter. Prefer specifying multiple words separated by
	// comma, for a better understanding of a word from different angles.
	Translation string `json:"translation" yaml:"translation" mapstructure:"translation"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *AiDictionaryEntryConfigMeaningsElem) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["definitionOriginal"]; raw != nil && !ok {
		return fmt.Errorf("field definitionOriginal in AiDictionaryEntryConfigMeaningsElem: required")
	}
	if _, ok := raw["definitionTranslated"]; raw != nil && !ok {
		return fmt.Errorf("field definitionTranslated in AiDictionaryEntryConfigMeaningsElem: required")
	}
	if _, ok := raw["neutralForm"]; raw != nil && !ok {
		return fmt.Errorf("field neutralForm in AiDictionaryEntryConfigMeaningsElem: required")
	}
	if _, ok := raw["pronounciation"]; raw != nil && !ok {
		return fmt.Errorf("field pronounciation in AiDictionaryEntryConfigMeaningsElem: required")
	}
	if _, ok := raw["synonyms"]; raw != nil && !ok {
		return fmt.Errorf("field synonyms in AiDictionaryEntryConfigMeaningsElem: required")
	}
	if _, ok := raw["translation"]; raw != nil && !ok {
		return fmt.Errorf("field translation in AiDictionaryEntryConfigMeaningsElem: required")
	}
	type Plain AiDictionaryEntryConfigMeaningsElem
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = AiDictionaryEntryConfigMeaningsElem(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *AiDictionaryEntryConfig) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["meanings"]; raw != nil && !ok {
		return fmt.Errorf("field meanings in AiDictionaryEntryConfig: required")
	}
	if _, ok := raw["sourceLanguage"]; raw != nil && !ok {
		return fmt.Errorf("field sourceLanguage in AiDictionaryEntryConfig: required")
	}
	type Plain AiDictionaryEntryConfig
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = AiDictionaryEntryConfig(plain)
	return nil
}
