/* eslint-disable */
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

/**
 * The unique identifier of the entity in uuid-v7 format
 */
export type Id = string;
/**
 * The list of BCP 47 language tags of the languages foreign to the user that are most commonly used in the learning process. Take this list as a priority when you try to detect the text language of the text foreign to the user. Although it is not guaranteed to completely match the text languages
 */
export type ForeignLanguages = string[];
export type ChatOutputDataParseTextFromForeign = {
  definitionParts: {
    /**
     * The text of word extracted. Keep this part small, it should not be longer than a typical dictionary entry point. Include only the word itself without any extra symbols. Do not include any punctuation symbols, enclosing parentheses or apostrophes an so on.
     */
    text: string;
    /**
     * A short translation of the word without additional formatting. Among several translation choices, choose the one that is the best fitting the original context from the user input text that was sent for this parsing.
     */
    translation: string;
    /**
     * The BCP 47 language tag of the language of that word. Null for unknown
     */
    languageOriginal: string;
    /**
     * The BCP 47 language tag of the language of the translation. It should match the requested 'translationLanguage'
     */
    languageTranslated: string;
  }[];
  /**
   * The full translation of the text to the requested language.
   */
  translation: {
    text: string;
    /**
     * The BCP 47 language tag of the language of the translation. It should match the requested 'translationLanguage'
     */
    language: string;
  };
} & ({
  definitionParts: {
    /**
     * The text of word extracted. Keep this part small, it should not be longer than a typical dictionary entry point. Include only the word itself without any extra symbols. Do not include any punctuation symbols, enclosing parentheses or apostrophes an so on.
     */
    text: string;
    /**
     * A short translation of the word without additional formatting. Among several translation choices, choose the one that is the best fitting the original context from the user input text that was sent for this parsing.
     */
    translation: string;
    /**
     * The BCP 47 language tag of the language of that word. Null for unknown
     */
    languageOriginal: string;
    /**
     * The BCP 47 language tag of the language of the translation. It should match the requested 'translationLanguage'
     */
    languageTranslated: string;
  }[];
  /**
   * The full translation of the text to the requested language.
   */
  translation: {
    text: string;
    /**
     * The BCP 47 language tag of the language of the translation. It should match the requested 'translationLanguage'
     */
    language: string;
  };
} | null);
/**
 * The list of BCP 47 language tags of the languages native to the user. Take this list as a priority when you try to detect the text language. Although it is not guaranteed to completely match the text languages
 */
export type NativeLanguages = string[];

export interface Main {
  model: Models;
  lensModel: LenseModels;
  WsMessageType: WsMessageType;
  WsMessageNameRequestToServer: WsMessageNameRequestToServer;
  WsMessageNameEventToServer: WsMessageNameEventToServer;
  WsMessageName: WsMessageName;
  WsMessageBase: WsMessageBase;
}
export interface Models {
  MessageBase: MessageBase;
  messages: MessageMap;
  AuthSession: AuthSession;
  AuthInfo: AuthInfo;
  Card: Card;
}
export interface MessageBase {
  input: {
    id: Id;
    name: string;
    data: {
      [k: string]: unknown;
    };
    authToken: string;
  };
  output: {
    id: Id;
    name: string;
    data: {
      [k: string]: unknown;
    } | null;
    errors: AppError[];
  };
}
/**
 * An application typed error.
 */
export interface AppError {
  name: ErrorName;
  message: string;
}
export interface MessageMap {
  ParseTextFromForeign: MessageParseTextFromForeign;
  DefineTerm: MessageDefineTerm;
  GetAuthInfo: MessageGetAuthInfo;
  GetDecks: MessageGetDecks;
  AddCard: MessageAddCard;
  GetCards: MessageGetCards;
}
export interface MessageParseTextFromForeign {
  input: {
    id: Id;
    name: Name;
    data: {
      chatInput: ChatInputParseTextFromForeign;
    };
    authToken: string;
  };
  output: {
    id: Id;
    name: Name1;
    data?: {
      chatOutput: ChatOutputDataParseTextFromForeign;
    } | null;
    errors: AppError[];
  };
}
export interface ChatInputParseTextFromForeign {
  text: string;
  originalLanguages: ForeignLanguages;
  /**
   * The BCP 47 language tag of the language that the user wants to translate the foreign text to.
   */
  translationLanguage: string;
}
export interface MessageDefineTerm {
  input: {
    id: Id;
    name: Name2;
    data: {
      chatInput: ChatInputDefineTerm;
    };
    authToken: string;
  };
  output: {
    id: Id;
    name: Name3;
    data?: {
      definition: Definition;
      decks: Deck[];
    } | null;
    errors: AppError[];
  };
}
export interface ChatInputDefineTerm {
  /**
   * A term to define
   */
  term: string;
  /**
   * A context from which the term is taken
   */
  context: string;
  originalLanguages: ForeignLanguages;
  /**
   * The BCP 47 language tag of the language that the user wants to translate the foreign text to.
   */
  translationLanguage: string;
}
/**
 * A detailed representation of a definition, including its original and neutral forms, pronunciations, translations, definitions, origin, and usage examples.
 */
export interface Definition {
  /**
   * The original language of the word in a BCP 47 format.
   */
  languageOriginal: string;
  /**
   * The language the word is translated to in a BCP 47 format.
   */
  languageTranslated: string;
  /**
   * The original word given, in the exact same grammatic form, capitalized.
   */
  originalWord: string;
  /**
   * The word in a neutral grammatic form.
   */
  neutralForm: string;
  /**
   * @minItems 1
   */
  pronounciations: [
    {
      /**
       * A pronunciation of the original word given.
       */
      transcription: string;
      /**
       * A description of the pronunciation. Like the area where it is commonly used.
       */
      description: string;
    },
    ...{
      /**
       * A pronunciation of the original word given.
       */
      transcription: string;
      /**
       * A description of the pronunciation. Like the area where it is commonly used.
       */
      description: string;
    }[]
  ];
  /**
   * An extensive translation to the language defined by a `languageTranslated` property, the more words the better. In case of multiple meanings, include all of them.
   */
  translation: string;
  /**
   * Common synonyms in the original language.
   */
  synonyms: string[];
  /**
   * An extensive definition in the original language.
   */
  definitionOriginal: string;
  /**
   * An extensive definition in the language defined by a `languageTranslated` property.
   */
  definitionTranslated: string;
  /**
   * The root parts of the word and the origin in the language defined by a `languageTranslated` property. If the original form from Part 1 is different from the neutral grammatic form from Part 2, explain that difference including all the details.
   */
  origin: string;
  /**
   * Three sentence examples of the usage of the original word in the same grammatic form followed by an translation in the language defined by a `languageTranslated` property. The sentence and the translation should be separated by one new line, while the examples themselves should be separated by three new lines. If there was a context from which that word was taken, include a phrase from that context in examples, replacing the first example.
   */
  examples: {
    /**
     * An example sentence in the original language using the word.
     */
    original: string;
    /**
     * The translation of the example sentence in the language defined by a `languageTranslated` property.
     */
    translation: string;
  }[];
}
export interface Deck {
  id: string;
  name: string;
}
export interface MessageGetAuthInfo {
  input: {
    id: Id;
    name: Name4;
    data: {};
    authToken: string;
  };
  output: {
    id: Id;
    name: Name5;
    data?: {
      authInfo: AuthInfo;
    } | null;
    errors: AppError[];
  };
}
export interface AuthInfo {
  user: User;
  userSettings: UserSettings;
}
export interface User {
  /**
   * UUID v7 string
   */
  id: string;
  /**
   * ISO 8601 date string
   */
  createdAt: string;
  /**
   * ISO 8601 date string
   */
  updatedAt: string;
  /**
   * ISO 8601 date string or null
   */
  deletedAt: string | null;
  email: string;
}
export interface UserSettings {
  /**
   * UUID v7 string
   */
  id: string;
  /**
   * ISO 8601 date string
   */
  createdAt: string;
  /**
   * ISO 8601 date string
   */
  updatedAt: string;
  /**
   * ISO 8601 date string or null
   */
  deletedAt: string | null;
  foreignLanguages: ForeignLanguages;
  /**
   * The BCP 47 language tag of the language that the user wants to translate the foreign text to.
   */
  translationLanguage: string;
  nativeLanguages: NativeLanguages;
  /**
   * The BCP 47 language tag of the language that the user wants to translate the text to.
   */
  primaryForeignLanguage: string;
}
export interface MessageGetDecks {
  input: {
    id: Id;
    name: Name6;
    data: {};
    authToken: string;
  };
  output: {
    id: Id;
    name: Name7;
    data?: {
      decks: Deck[];
    } | null;
    errors: AppError[];
  };
}
export interface MessageAddCard {
  input: {
    id: Id;
    name: Name8;
    data: {
      card: Card;
      deckId: string;
    };
    authToken: string;
  };
  output: {
    id: Id;
    name: Name9;
    data?: {} | null;
    errors: AppError[];
  };
}
export interface Card {
  /**
   * uuid-v7
   */
  id: string;
  definition: Definition;
  fieldAnswers: UserCardFieldAnswer[];
}
export interface UserCardFieldAnswer {
  userCardFieldName: string;
  text: string;
}
export interface MessageGetCards {
  input: {
    id: Id;
    name: Name10;
    data: {
      deckId: string;
    };
    authToken: string;
  };
  output: {
    id: Id;
    name: Name11;
    data?: {
      cards: Card[];
    } | null;
    errors: AppError[];
  };
}
export interface AuthSession {
  authToken: string;
}
export interface LenseModels {
  User: User;
  UserSettings: UserSettings;
}
export interface WsMessageBase {
  name: WsMessageName;
  id: string;
  responseForId?: string;
  data: {
    [k: string]: unknown;
  };
  errors: AppError[];
}

/**
 * The code name of the error.
 */
export enum ErrorName {
  Unknown = "Unknown",
  Internal = "Internal",
  Ai_CreateCompletion = "Ai_CreateCompletion",
  AI_ResponseUnmarshal = "AI_ResponseUnmarshal",
  JsonSchema_MessageInput = "JsonSchema_MessageInput",
  JsonSchema_MessageOutput = "JsonSchema_MessageOutput",
  NotFound_MessageName = "NotFound_MessageName",
  FromAi_Critical = "FromAi_Critical",
  ChatAiError = "ChatAiError",
  AuthRequired = "AuthRequired"
}
export enum Name {
  ParseTextFromForeign = "ParseTextFromForeign"
}
export enum Name1 {
  ParseTextFromForeign = "ParseTextFromForeign"
}
export enum Name2 {
  DefineTerm = "DefineTerm"
}
export enum Name3 {
  DefineTerm = "DefineTerm"
}
export enum Name4 {
  GetAuthInfo = "GetAuthInfo"
}
export enum Name5 {
  GetAuthInfo = "GetAuthInfo"
}
export enum Name6 {
  GetDecks = "GetDecks"
}
export enum Name7 {
  GetDecks = "GetDecks"
}
export enum Name8 {
  AddCard = "AddCard"
}
export enum Name9 {
  AddCard = "AddCard"
}
export enum Name10 {
  GetCards = "GetCards"
}
export enum Name11 {
  GetCards = "GetCards"
}
/**
 * Type of message
 */
export enum WsMessageType {
  QueryToServer = "QueryToServer",
  QueryFromServer = "QueryFromServer",
  EventToServer = "EventToServer",
  EventFromServer = "EventFromServer"
}
export enum WsMessageNameRequestToServer {
  LenseQuery = "LenseQuery"
}
export enum WsMessageNameEventToServer {
  Mutation = "Mutation"
}
export enum WsMessageName {
  LenseQuery = "LenseQuery",
  Mutation = "Mutation"
}
